"use strict";(self.webpackChunkfresher_training_doc=self.webpackChunkfresher_training_doc||[]).push([[932],{5422:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var o=n(4848),a=n(8453);const s={},i="Object pool",r={id:"Topics/pool",title:"Object pool",description:'The object pool pattern is a software creational design pattern that uses a set of initialized objects kept ready to use \u2013 a "pool" \u2013 rather than allocating and destroying them on demand. A client of the pool will request an object from the pool and perform operations on the returned object. When the client has finished, it returns the object to the pool rather than destroying it. This can offer a significant performance boost in situations where the cost of initializing and destroy a class instance and prevent memory fragmentation.',source:"@site/docs/Topics/2.pool.md",sourceDirName:"Topics",slug:"/Topics/pool",permalink:"/fresher-training-doc/docs/Topics/pool",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Topics/2.pool.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Tween",permalink:"/fresher-training-doc/docs/Topics/tween"},next:{title:"Event emitter",permalink:"/fresher-training-doc/docs/Topics/event"}},l={},c=[{value:"Memory fragmentation",id:"memory-fragmentation",level:3},{value:"Object Pool Pattern",id:"object-pool-pattern",level:3}];function h(e){const t={code:"code",h1:"h1",h3:"h3",header:"header",img:"img",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"object-pool",children:"Object pool"})}),"\n",(0,o.jsx)(t.p,{children:'The object pool pattern is a software creational design pattern that uses a set of initialized objects kept ready to use \u2013 a "pool" \u2013 rather than allocating and destroying them on demand. A client of the pool will request an object from the pool and perform operations on the returned object. When the client has finished, it returns the object to the pool rather than destroying it. This can offer a significant performance boost in situations where the cost of initializing and destroy a class instance and prevent memory fragmentation.'}),"\n",(0,o.jsx)(t.h3,{id:"memory-fragmentation",children:"Memory fragmentation"}),"\n",(0,o.jsx)(t.p,{children:"Memory fragmentation is a condition where memory is divided into small, non-contiguous blocks. This can happen when memory is allocated and deallocated in a random order. This can lead to a situation where the memory is not used efficiently. The memory is fragmented into small blocks, but the program needs a large block of memory. This can lead to a situation where the program runs out of memory, even though there is enough memory available."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:n(4900).A+"",width:"1040",height:"639"})}),"\n",(0,o.jsx)(t.h3,{id:"object-pool-pattern",children:"Object Pool Pattern"}),"\n",(0,o.jsx)(t.p,{children:"Fragmentation and allocation/deallocation of memory can be expensive. There is a simple solution is that grab a big chunk of memory when the game starts, and don't free it until the game ends."}),"\n",(0,o.jsx)(t.p,{children:"Here is a simple example of an object pool that creates a pool of bullets. The pool is created with a class that represents the object to be pooled. The pool has a method to get an object from the pool and a method to release an object back to the pool."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"class ObjectPool {\n    constructor(ObjectClass) {\n        this.ObjectClass = ObjectClass;\n        this._pool = [];\n    }\n    \n    get() {\n        if (this._pool.length > 0) {\n            return this._pool.pop();\n        }\n        return new this.ObjectClass();\n    }\n    \n    release(obj) {\n        this._pool.push(obj);\n    }\n    \n    clear() {\n        this._pool = [];\n    }\n}\n\nclass GameObject {\n    constructor() {\n        this.x = 0;\n        this.y = 0;\n        this.active = false;\n    }\n}\n\nclass Bullet extends GameObject {\n    constructor() {\n        super();\n        this.speed = 5;\n    }\n    \n    update(dt) {\n        this.x += this.speed * dt;\n    }\n}\n\nconst bulletPool = new ObjectPool(Bullet);\nconst bullets = [];\nlet timeCounter = 0;\n\nfunction update(dt) {\n    timeCounter += dt;\n    \n    // spawn bullets every second\n    if (timeCounter >= 1) {\n        spawnBullets();\n        timeCounter = 0;\n    }\n    \n    // update bullets and despawn them if they are out of the screen\n    for (let i = 0; i < bullets.length; i++) {\n        const bullet = bullets[i];\n        bullet.update(dt);\n        if (bullet.x > 800) {\n            bullet.active = false;\n            bulletPool.release(bullet);\n            bullets.splice(i, 1);\n            i--;\n        }\n    }\n}\n\nfunction spawnBullets() {\n    // spawn from 1 to 10 bullets\n    let numBullets = Math.random() * 10;\n    for (let i = 0; i < numBullets; i++) {\n        const bullet = bulletPool.get();\n        bullet.active = true;\n        bullet.y = Math.random() * 800;\n        bullets.push(bullet);\n    }\n}\n"})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},4900:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/pool-fragmentation-cf3123dc6ca86804b510e3af5fa3e475.png"},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var o=n(6540);const a={},s=o.createContext(a);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);