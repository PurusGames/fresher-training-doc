"use strict";(self.webpackChunkfresher_training_doc=self.webpackChunkfresher_training_doc||[]).push([[295],{9579:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>n,metadata:()=>r,toc:()=>l});var i=o(4848),s=o(8453);const n={},a="2D HTML5 Game Tutorial",r={id:"2d-context/physics",title:"2D HTML5 Game Tutorial",description:"Collision detection and physics",source:"@site/docs/2d-context/physics.md",sourceDirName:"2d-context",slug:"/2d-context/physics",permalink:"/docs/2d-context/physics",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/2d-context/physics.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"2D HTML5 Game Tutorial",permalink:"/docs/2d-context/introduction"},next:{title:"2D HTML5 Game Tutorial",permalink:"/docs/2d-context/shapes-paths-text"}},c={},l=[{value:"Collision detection and physics",id:"collision-detection-and-physics",level:2},{value:"Create some moving objects",id:"create-some-moving-objects",level:3},{value:"Why do you need collision detection?",id:"why-do-you-need-collision-detection",level:3},{value:"Check for collisions between objects",id:"check-for-collisions-between-objects",level:3},{value:"When do you check for collisions?",id:"when-do-you-check-for-collisions",level:3},{value:"Collision detection between rectangles",id:"collision-detection-between-rectangles",level:3},{value:"Check if two circles overlap",id:"check-if-two-circles-overlap",level:3},{value:"What about other shapes?",id:"what-about-other-shapes",level:3},{value:"What are hitboxes and how do you use them?",id:"what-are-hitboxes-and-how-do-you-use-them",level:3},{value:"React to collisions with physics",id:"react-to-collisions-with-physics",level:3},{value:"Find the direction and speed of the collision",id:"find-the-direction-and-speed-of-the-collision",level:3},{value:"Change velocity of the moving objects",id:"change-velocity-of-the-moving-objects",level:3},{value:"Add mass, impulse and momentum",id:"add-mass-impulse-and-momentum",level:3},{value:"Get the heading of the objects",id:"get-the-heading-of-the-objects",level:3},{value:"Add the effects of gravity",id:"add-the-effects-of-gravity",level:3},{value:"Confine the movement space of the objects",id:"confine-the-movement-space-of-the-objects",level:3},{value:"Absorb impact by implementing restitution",id:"absorb-impact-by-implementing-restitution",level:3},{value:"Ways of improving performance",id:"ways-of-improving-performance",level:3},{value:"Handle fast-moving objects",id:"handle-fast-moving-objects",level:3}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"2d-html5-game-tutorial",children:"2D HTML5 Game Tutorial"})}),"\n",(0,i.jsx)(t.h2,{id:"collision-detection-and-physics",children:"Collision detection and physics"}),"\n",(0,i.jsx)(t.p,{children:"Perform collision detection and react with physics, using JavaScript. Check for overlap between shapes, apply hitboxes and calculate new velocities. Make it more natural with object mass, gravity and restitution. By the end of this tutorial, you'll have a basic physics simulation running in your game."}),"\n",(0,i.jsx)(t.h3,{id:"create-some-moving-objects",children:"Create some moving objects"}),"\n",(0,i.jsx)(t.p,{children:"Before you can detect collisions between moving objects, you'll need some objects to begin with. In the previous tutorial you've learned how to move a single rectangle. Let's expand that logic and create a whole bunch of moving objects to fill your game. First, define a new type of game object. It's going to be a simple square."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"class Square extends GameObject\r\n{\r\n    constructor (context, x, y, vx, vy){\r\n        super(context, x, y, vx, vy);\r\n\r\n        // Set default width and height\r\n        this.width = 50;\r\n        this.height = 50;\r\n    }\r\n\r\n    draw(){\r\n        // Draw a simple square\r\n        this.context.fillStyle = this.isColliding?'#ff8080':'#0099b0';\r\n        this.context.fillRect(this.x, this.y, this.width, this.height);\r\n    }\r\n\r\n    update(secondsPassed){\r\n        // Move with set velocity\r\n        this.x += this.vx * secondsPassed;\r\n        this.y += this.vy * secondsPassed;\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This code might look a bit familiar. There is a draw() and a update() function, just like in the previous tutorial. Only this time it is baked into a separate square ",(0,i.jsx)(t.a,{href:"https://javascript.info/class",children:"class"}),". This way you can create many instances of a square and they all use the same logic to draw and update. You'll have the behavior and looks of the square in one, easy-to-manage, place."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"fillStyle"})," in this new class is tweaked a bit. When this object is colliding, it will change color from blue to red. You'll see this in action when the first collisions are detected. For now, all squares will be blue."]}),"\n",(0,i.jsxs)(t.p,{children:["All the squares ",(0,i.jsx)(t.strong,{children:"inherit"})," from the ",(0,i.jsx)(t.code,{children:"GameObject"})," class. Every game object has a position and a speed. This enables you to easily create new types of game objects. They ",(0,i.jsx)(t.a,{href:"https://javascript.info/class-inheritance",children:"inherit"})," the attributes and methods of the ",(0,i.jsx)(t.code,{children:"GameObject"})," class. The square is just an example, but you could also make objects like enemies or players for your game this way."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"class GameObject\r\n{\r\n    constructor (context, x, y, vx, vy){\r\n        this.context = context;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.vx = vx;\r\n        this.vy = vy;\r\n\r\n        this.isColliding = false;\r\n    }\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["You can create a ",(0,i.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new",children:"new"})," instance of a class by using the new keyword. Make some squares to fill up your game world using this ",(0,i.jsx)(t.code,{children:"createWorld()"})," function."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"let gameObjects;\r\n\r\nfunction createWorld(){\r\n    gameObjects = [\r\n        new Square(context, 250, 50, 0, 50),\r\n        new Square(context, 250, 300, 0, -50),\r\n        new Square(context, 150, 0, 50, 50),\r\n        new Square(context, 250, 150, 50, 50),\r\n        new Square(context, 350, 75, -50, 50),\r\n        new Square(context, 300, 300, 50, -50)\r\n    ];\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the function, a bunch of squares are created. They are passed a position and speed as arguments. For now, this function is very static, but you could easily modify it to create more random squares or use some ",(0,i.jsx)(t.strong,{children:"spawning algorithm"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Everything is in place to draw squares now. Update your game loop with the following code to loop over the newly created game objects and draw them on the screen."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"function gameLoop(timeStamp)\r\n{\r\n    secondsPassed = (timeStamp - oldTimeStamp) / 1000;\r\n    oldTimeStamp = timeStamp;\r\n\r\n    // Loop over all game objects\r\n    for (let i = 0; i < gameObjects.length; i++) {\r\n        gameObjects[i].update(secondsPassed);\r\n    }\r\n\r\n    clearCanvas();\r\n\r\n    // Do the same to draw\r\n    for (let i = 0; i < gameObjects.length; i++) {\r\n        gameObjects[i].draw();\r\n    }\r\n\r\n    window.requestAnimationFrame(gameLoop);\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As you can see, ",(0,i.jsx)(t.code,{children:"update()"})," and ",(0,i.jsx)(t.code,{children:"draw()"})," are no longer just called once per iteration. There are called once for every object on screen, every iteration."]}),"\n",(0,i.jsxs)(t.p,{children:["This way the implementation of ",(0,i.jsx)(t.code,{children:"update()"})," and ",(0,i.jsx)(t.code,{children:"draw()"})," is ",(0,i.jsx)(t.strong,{children:"object-specific"}),". For the game loop it doesn't matter what kind of objects you are trying to draw, as long as they have an ",(0,i.jsx)(t.code,{children:"update()"})," and ",(0,i.jsx)(t.code,{children:"draw()"})," function."]}),"\n",(0,i.jsx)(t.p,{children:"For the square you are using, it will draw a simple square and move it in a straight line. But imagine other types of objects who have their own implementation of the two functions and have behavior and looks of their own. This game loop can handle it."}),"\n",(0,i.jsxs)(t.p,{children:["By the way, did you notice the ",(0,i.jsx)(t.code,{children:"use strict"})," line missing in these new classes? That's because classes defined with the class keyword are strict by default. So, there is no need to specifically add ",(0,i.jsx)(t.code,{children:"use strict"})," in these classes."]}),"\n",(0,i.jsx)(t.p,{children:"Take a look at the result:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(3190).A+"",width:"600",height:"321"})}),"\n",(0,i.jsxs)(t.p,{children:["You can see a bunch of rectangles getting drawn now. They each have their own starting position and move in a different direction. Just as defined in the ",(0,i.jsx)(t.code,{children:"createWorld()"})," function. You can tweak the variables to create new types of squares."]}),"\n",(0,i.jsx)(t.h3,{id:"why-do-you-need-collision-detection",children:"Why do you need collision detection?"}),"\n",(0,i.jsxs)(t.p,{children:["The squares may overlap in their movement, but that doesn't do much for now. It would be cool if the squares could interact and behave like actual ",(0,i.jsx)(t.strong,{children:"solid objects"})," and bounce off of each other.  make this happen, they would have to start with knowing they're colliding with one another. That's where ",(0,i.jsx)(t.strong,{children:"collision detection"})," comes in."]}),"\n",(0,i.jsx)(t.p,{children:"Collision detection is the art of detecting if two objects are colliding with each other, or did so between now and the last frame. It's the first step of implementing physics in your game."}),"\n",(0,i.jsx)(t.h3,{id:"check-for-collisions-between-objects",children:"Check for collisions between objects"}),"\n",(0,i.jsx)(t.p,{children:"The squares are moving on the screen, but there is no form of interaction jet. It's like they don't notice each other. Let's do something about that."}),"\n",(0,i.jsxs)(t.p,{children:["You are going to check for collisions between the moving objects. That requires you to loop over all objects and check if any of them overlaps with another. You'll need a ",(0,i.jsx)(t.a,{href:"https://www.educba.com/nested-loop-in-javascript/",children:"nested for loop"})," for this."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"function detectCollisions(){\r\n    let obj1;\r\n    let obj2;\r\n\r\n    // Reset collision state of all objects\r\n    for (let i = 0; i < gameObjects.length; i++) {\r\n        gameObjects[i].isColliding = false;\r\n    }\r\n\r\n    // Start checking for collisions\r\n    for (let i = 0; i < gameObjects.length; i++)\r\n    {\r\n        obj1 = gameObjects[i];\r\n        for (let j = i + 1; j < gameObjects.length; j++)\r\n        {\r\n            obj2 = gameObjects[j];\r\n\r\n            // Compare object1 with object2\r\n            if (rectIntersect(obj1.x, obj1.y, obj1.width, obj1.height, obj2.x, obj2.y, obj2.width, obj2.height)){\r\n                obj1.isColliding = true;\r\n                obj2.isColliding = true;\r\n            }\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"All objects are checked for intersection with each other. The second for loop is a bit smarter and skips all previous checked items. You don't have to check objects twice. If they overlap the first time, they will too the second time. And of course, you don't have to check an object against itself, it would always overlap."}),"\n",(0,i.jsxs)(t.p,{children:["The function calls ",(0,i.jsx)(t.code,{children:"rectIntersect()"})," for every combination of objects. When it finds a collision, it sets ",(0,i.jsx)(t.code,{children:"isColliding"})," to true for both objects involved."]}),"\n",(0,i.jsxs)(t.p,{children:["Remember the ",(0,i.jsx)(t.code,{children:"draw()"})," function from the square? It will react to ",(0,i.jsx)(t.code,{children:"isColliding"})," and draw the square in a different color. You can easily see when two objects overlap."]}),"\n",(0,i.jsx)(t.h3,{id:"when-do-you-check-for-collisions",children:"When do you check for collisions?"}),"\n",(0,i.jsxs)(t.p,{children:["Just as with the draw() method, you want to update the position of all your game objects first, before checking for collisions. This way you'll always check for overlapping objects in their ",(0,i.jsx)(t.strong,{children:"most recent state"}),". If you do it the other way around and check for collisions before updating, you'll be checking for overlap on the state of the previous frame. You'll always run behind the facts."]}),"\n",(0,i.jsx)(t.p,{children:"Another option would be to do the collision check in the right order, but iterative. You would update object-a, check object-a for overlap with all other objects, update object-b, check object-b for overlap with all other objects, and so on. This is also an incorrect way of doing a collision check. Imagine object-a would be in collision with object-b after updating object-a's position. The system would detect a collision, even though it might not have been the case when object-b would have moved first too. That's why you'll always have to update all objects, before doing a collision check."}),"\n",(0,i.jsxs)(t.p,{children:["The correct order for your game loop is, ",(0,i.jsx)(t.strong,{children:"update"}),", ",(0,i.jsx)(t.strong,{children:"collision check"}),", ",(0,i.jsx)(t.strong,{children:"clear canvas"}),", ",(0,i.jsx)(t.strong,{children:"draw"}),". So, place the ",(0,i.jsx)(t.code,{children:"detectCollisions()"})," function right after the loop for updating all game objects. Your total game loop now looks like this:"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(2904).A+"",width:"1500",height:"297"})}),"\n",(0,i.jsx)(t.h3,{id:"collision-detection-between-rectangles",children:"Collision detection between rectangles"}),"\n",(0,i.jsxs)(t.p,{children:["The last piece of the puzzle is the ",(0,i.jsx)(t.code,{children:"rectIntersect()"})," method. You can use it to check if two rectangles overlap. Checking for overlap between two ",(0,i.jsx)(t.strong,{children:"axis-aligned"})," (unrotated) rectangles is pretty simple and straight forward. You can probably come up with a method of checking for overlap on both axis by using the position and size of the rectangles. There are a lot of ways to do this, but the next method is very efficient:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {\r\n    // Check x and y for overlap\r\n    if (x2 > w1 + x1 || x1 > w2 + x2 || y2 > h1 + y1 || y1 > h2 + y2){\r\n        return false;\r\n    }\r\n    return true;\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The code detects rectangles clearly overlapping halfway, but also works in the case of one small rectangle falling completely in a large one.",(0,i.jsx)("br",{}),"\r\nWith this piece of code in place, you can finally check out the result. Here are the squares again, but this time they react upon each other."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(7204).A+"",width:"600",height:"321"})}),"\n",(0,i.jsxs)(t.p,{children:["After detecting a collision, the ",(0,i.jsx)(t.code,{children:"isColliding"})," attribute is set to true. This makes the squares draw in red. You can clearly see when two objects overlap now."]}),"\n",(0,i.jsx)(t.h3,{id:"check-if-two-circles-overlap",children:"Check if two circles overlap"}),"\n",(0,i.jsx)(t.p,{children:"You have a method now for checking collision between unrotated rectangles. But what if you want to do the same for circles? Well, that's not that hard either."}),"\n",(0,i.jsxs)(t.p,{children:["Imagine you have two circles, each with their own radius. They are placed with a distance between them. The circles would overlap if the ",(0,i.jsx)(t.strong,{children:"distance is smaller"})," than the ",(0,i.jsx)(t.strong,{children:"sum of the radius"})," of both circles. Since circles are round, this would even work when rotating the objects, they don't have to be axis-aligned."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(8789).A+"",width:"512",height:"294"})}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["Calculate distance between two points",(0,i.jsx)("br",{}),"\r\nYou can calculate the distance between two points with the following formula:",(0,i.jsx)("br",{}),"\r\nc = sqrt((x1 - x2)2 + (y1 - y2)2)",(0,i.jsx)("br",{}),"\r\nIf you think of \u0394x and \u0394y as two sides of a triangle, it basically applies the ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Pythagorean_theorem",children:"Pythagorean theorem"})," to compute the size of the straight line between the points, c, the distance."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"So, if this distance is smaller than or equal to the radius of circle-a plus circle-b, the circles overlap or touch. This principle is used in the next function:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"circleIntersect(x1, y1, r1, x2, y2, r2) {\r\n\r\n    // Calculate the distance between the two circles\r\n    let squareDistance = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\r\n\r\n    // When the distance is smaller or equal to the sum\r\n    // of the two radius, the circles touch or overlap\r\n    return squareDistance <= ((r1 + r2) * (r1 + r2))\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As you can see, the formula is tweaked a bit. Multiplication is much faster than getting the square root with ",(0,i.jsx)(t.code,{children:"Math.sqrt()"}),",  the distance is calculated without getting the root and the sum of the radii is multiplied by itself. The outcome stays the same, but the performance is better."]}),"\n",(0,i.jsx)(t.p,{children:"Here is the same example as before, but with circles this time:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(869).A+"",width:"600",height:"321"})}),"\n",(0,i.jsx)(t.h3,{id:"what-about-other-shapes",children:"What about other shapes?"}),"\n",(0,i.jsx)(t.p,{children:"In this article, collision detection is only covered for two types of shapes. But what if your game objects consist of other, more complex, shapes or even images and you want to perform collision checks between them?"}),"\n",(0,i.jsxs)(t.p,{children:["Well, for geometric shapes you can find other formulas to detect when two objects overlap. Here's a website who covers ",(0,i.jsx)(t.a,{href:"http://www.jeffreythompson.org/collision-detection/table_of_contents.php",children:"collision detection for a lot of different shapes"}),". Overall, more complex shapes make collision detection more difficult. And for images you could apply ",(0,i.jsx)(t.strong,{children:"pixel perfect"})," collision detection. The downside of this is that it's a super CPU-heavy operation. Imagine having to match every pixel with one another, it would be a heck of a job."]}),"\n",(0,i.jsxs)(t.p,{children:["That's why, to make things easier and put less stress on your system, developers often use ",(0,i.jsx)(t.strong,{children:"hitboxes"})," to detect collisions between complexly shaped game objects. It's a way to make collision detection easier and uses only basic geometric shapes, like the rectangles and circles covered in this tutorial. So, before you start building support for all kinds of complex shapes, try to think of a simple way to achieve the same effect, with basic shapes and hitboxes."]}),"\n",(0,i.jsx)(t.h3,{id:"what-are-hitboxes-and-how-do-you-use-them",children:"What are hitboxes and how do you use them?"}),"\n",(0,i.jsx)(t.p,{children:"Hitboxes are imaginary geometric shapes around game objects that are used to determine collision detection. Imagine you have a player figure. You won't check its arms and legs for collision but instead just check a big imaginary rectangle that's placed around the player."}),"\n",(0,i.jsx)(t.p,{children:"You could simply use the function for rectangle collision detection, you've applied before, to check the hitboxes for collisions. It's far less CPU-intensive and makes supporting complex shapes in your game much easier. In some special cases, you could even use multiple hitboxes per game object. It would still outperform the pixel perfect solution."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(1939).A+"",width:"1411",height:"613"})}),"\n",(0,i.jsx)(t.p,{children:"The image above demonstrates the different types of collision detection. They each have their own advantages and disadvantages:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Pixel perfect"})," - Super precise collision detection, but it requires some serious system resources. In most cases this is an overkill."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Hitbox"})," - Much better performance, but the collision detection can be pretty imprecise. In many game scenarios though, this doesn't really matter."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Multiple hitboxes"})," - Less efficient than a single hitbox but it still outperforms the pixel perfect variant. And you can support complex shapes. This is a nice option to use for important game objects that need some extra precision, like the player with limbs like mentioned before. You could make a hitbox for the core and separates ones for arms, legs and the head."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"react-to-collisions-with-physics",children:"React to collisions with physics"}),"\n",(0,i.jsxs)(t.p,{children:["You now have game objects who can detect a collision and change color. But wouldn't it be much cooler if the objects bounce off on each other, like real life objects? It's time to apply some ",(0,i.jsx)(t.strong,{children:"physics"})," to your game."]}),"\n",(0,i.jsxs)(t.p,{children:["To change the ",(0,i.jsx)(t.strong,{children:"velocity"})," of the moving objects, you'll need to find out in what ",(0,i.jsx)(t.strong,{children:"direction"})," and with what ",(0,i.jsx)(t.strong,{children:"speed"})," the collision took place. You can then apply a change in velocity to the collided objects. The principles behind this work for both rectangles and circles."]}),"\n",(0,i.jsx)(t.h3,{id:"find-the-direction-and-speed-of-the-collision",children:"Find the direction and speed of the collision"}),"\n",(0,i.jsx)(t.p,{children:"Imagine the next collision between two game objects. Both objects have a speed and direction of their own. They don't hit each other exactly straight on, but just happen to cause a collision while moving on their own course."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(18).A+"",width:"320",height:"270"})}),"\n",(0,i.jsxs)(t.p,{children:["You'll want to find out the speed and direction of the collision so you can apply it to the velocity of the game objects. Start by creating a ",(0,i.jsx)(t.strong,{children:"vector"})," for the collision that took place. This vector is nothing more than the difference in x and y between the two colliding objects. You can see it as an arrow with ",(0,i.jsx)(t.strong,{children:"length"})," and ",(0,i.jsx)(t.strong,{children:"direction"}),". With vectors, the length is also called ",(0,i.jsx)(t.a,{href:"https://onlinemschool.com/math/library/vector/length/",children:"magnitude"}),". Calculate the collision vector like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"let vCollision = {x: obj2.x - obj1.x, y: obj2.y - obj1.y};\n"})}),"\n",(0,i.jsx)(t.p,{children:"In the example of the two game objects, the collision vector will look like this:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(5949).A+"",width:"320",height:"236"})}),"\n",(0,i.jsx)(t.p,{children:"The magnitude in this case, is equal to the distance between the two colliding objects. It has nothing to do with speed yet. But you can use the direction of the vector. To get to the direction, you need to take away the factor of the distance."}),"\n",(0,i.jsxs)(t.p,{children:["Let's first calculate the ",(0,i.jsx)(t.strong,{children:"distance"})," of the collision vector. You can use the same formula as you did before to calculate the distance between two colliding circles. So the code becomes:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"let distance = Math.sqrt((obj2.x-obj1.x)*(obj2.x-obj1.x) + (obj2.y-obj1.y)*(obj2.y-obj1.y));\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now use the distance to compute a ",(0,i.jsx)(t.strong,{children:"normalized collision vector"}),". You basically remove the distance as a factor in the collision vector, so you are left with just a direction. The collision norm is in the same direction as the collision vector, only with norm/magnitude/length 1. You also call this an ",(0,i.jsx)(t.a,{href:"https://mathworld.wolfram.com/UnitVector.html",children:"unit vector"}),". You can calculate the normalized vector like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"let vCollisionNorm = {x: vCollision.x / distance, y: vCollision.y / distance};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This will basically leave you with just a direction for the collision. In the example of the two game objects, it will look like this:\r\n",(0,i.jsx)(t.img,{src:o(3728).A+"",width:"320",height:"227"})]}),"\n",(0,i.jsxs)(t.p,{children:["You now have a ",(0,i.jsx)(t.strong,{children:"direction"}),". This is the direction in which the collision took place. All you need now is the collision ",(0,i.jsx)(t.strong,{children:"speed"})," and you'll be able to calculate how the velocity of the objects will be affected by the collision. You can calculate the speed of the collision like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"let vRelativeVelocity = {x: obj1.vx - obj2.vx, y: obj1.vy - obj2.vy};\r\nlet speed = vRelativeVelocity.x * vCollisionNorm.x + vRelativeVelocity.y * vCollisionNorm.y;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As first row in the example code, another vector is created with the relative velocity of the objects. It's like the vector you would have left if you would make one of the game objects stationary. (You can read more about ",(0,i.jsx)(t.a,{href:"https://www.schoolphysics.co.uk/age16-19/Mechanics/Kinematics/text/Relative_velocity/index.html",children:"relative velocities"})," here.) It's easier to understand in the next example. The vectors of the two game objects are displayed on top of each other, so you can visualize the ",(0,i.jsx)(t.strong,{children:"relative velocity vector"}),":"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(9661).A+"",width:"320",height:"380"})}),"\n",(0,i.jsxs)(t.p,{children:["Together with the collision normal, the relative velocity vector is used to calculate the ",(0,i.jsx)(t.strong,{children:"dot product"})," of the two vectors. The dot product is the length of the projection of relative velocity on the collision normal. Or in other words, the length of the velocity vector when it's in the direction of the collision. Learn more about ",(0,i.jsx)(t.a,{href:"https://www.mathsisfun.com/algebra/vectors-dot-product.html",children:"dot products"})," here. Learn more about ",(0,i.jsx)(t.a,{href:"http://victorjs.org/",children:"vector operations"})," here."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(7490).A+"",width:"320",height:"287"})}),"\n",(0,i.jsxs)(t.p,{children:["The dot product is equal to the ",(0,i.jsx)(t.strong,{children:"speed"})," of the collision. So that's it, you've got a speed and direction of the collision between the two objects. You can apply this to the velocity of the game objects and make them bounce off of each other."]}),"\n",(0,i.jsx)(t.h3,{id:"change-velocity-of-the-moving-objects",children:"Change velocity of the moving objects"}),"\n",(0,i.jsx)(t.p,{children:"The speed of the collision can be positive or negative. When it's positive, the objects are moving toward each other. When it's negative, they move away. When objects move away, there is no need to perform any further action. They will move out of collision on their own."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"if (speed < 0) {\r\n    break;\r\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"For the other case, when objects are moving toward each other, apply the speed in the direction of the collision. Both objects get the same change in velocity from the collision. Subtract or add the velocity to the velocity of the two collided objects."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"obj1.vx -= (speed * vCollisionNorm.x);\r\nobj1.vy -= (speed * vCollisionNorm.y);\r\nobj2.vx += (speed * vCollisionNorm.x);\r\nobj2.vy += (speed * vCollisionNorm.y);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["That's it, by applying speed to direction you calculate the ",(0,i.jsx)(t.strong,{children:"collision velocity"}),". And that velocity is now processed in the velocity of the objects involved. Your game objects should bounce in a natural looking way."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(218).A+"",width:"600",height:"322"})}),"\n",(0,i.jsx)(t.h3,{id:"add-mass-impulse-and-momentum",children:"Add mass, impulse and momentum"}),"\n",(0,i.jsxs)(t.p,{children:["You can apply physics even further and take ",(0,i.jsx)(t.strong,{children:"mass"})," into the equation by calculating the ",(0,i.jsx)(t.strong,{children:"collision impulse"})," from the speed. Use the impulse to calculate ",(0,i.jsx)(t.strong,{children:"momentum"}),". Heavy objects will push light ones aside."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"let impulse = 2 * speed / (obj1.mass + obj2.mass);\r\nobj1.vx -= (impulse * obj2.mass * vCollisionNorm.x);\r\nobj1.vy -= (impulse * obj2.mass * vCollisionNorm.y);\r\nobj2.vx += (impulse * obj1.mass * vCollisionNorm.x);\r\nobj2.vy += (impulse * obj1.mass * vCollisionNorm.y);\n"})}),"\n",(0,i.jsx)(t.p,{children:"If you have two objects with a mass of 1, the impulse is just equal to the speed. In other cases, you basically split the speed into many small parts. Heavy objects receive a few of those parts as momentum, light objects a lot. This makes the lighter objects more effected by the collision."}),"\n",(0,i.jsx)(t.p,{children:"If you have two objects with a mass of 1, the impulse is just equal to the speed. In other cases, you basically split the speed into many small parts. Heavy objects receive a few of those parts as momentum, light objects a lot. This makes the lighter objects more effected by the collision."}),"\n",(0,i.jsxs)(t.p,{children:["Don't forget to add mass to your game objects. The ",(0,i.jsx)(t.code,{children:"GameObject"})," class is a good place to store mass. You can modify the ",(0,i.jsx)(t.code,{children:"createWorld()"})," function to pass mass as an argument via the ",(0,i.jsx)(t.code,{children:"Circle"})," and ",(0,i.jsx)(t.code,{children:"Rectangle"})," classes."]}),"\n",(0,i.jsx)(t.p,{children:"Here's an example that's modified to create a lot of small circles and two larger ones. (The spawning algorithm isn't very smart so the objects might start in collision)"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(8306).A+"",width:"600",height:"321"})}),"\n",(0,i.jsx)(t.p,{children:"In the example, the big circles have a very large mass compared to the smaller circles. They push everything out of their way. But when the two heavy objects hit each other, they bounce off too."}),"\n",(0,i.jsx)(t.h3,{id:"get-the-heading-of-the-objects",children:"Get the heading of the objects"}),"\n",(0,i.jsx)(t.p,{children:"The objects are constantly colliding and changing direction. For a game it would be helpful to know which direction exactly, so you can add rotated textures or build game logic based on it. Let's calculate it!"}),"\n",(0,i.jsxs)(t.p,{children:["You can easily get the ",(0,i.jsx)(t.strong,{children:"angle of the objects"})," by using ",(0,i.jsx)(t.code,{children:"Math.atan2()"})," on the x and y velocities. The result is in The result is in ",(0,i.jsx)(t.strong,{children:"radians"}),", use ",(0,i.jsx)(t.code,{children:"Math.PI"})," to translate it to ",(0,i.jsx)(t.strong,{children:"degrees"}),". Here's an example which calculates the angle in your ",(0,i.jsx)(t.code,{children:"update()"})," function:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"update(secondsPassed) {\r\n    // Move with set velocity\r\n    this.x += this.vx * secondsPassed;\r\n    this.y += this.vy * secondsPassed;\r\n\r\n    // Calculate the angle (vy before vx)\r\n    let radians = Math.atan2(this.vy, this.vx);\r\n\r\n    // Convert to degrees\r\n    let degrees = 180 * radians / Math.PI;\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["You can use the angle later in your game, to ",(0,i.jsx)(t.strong,{children:"draw rotated images"}),". For now, rotating isn't so interesting since the circle is a plain shape. You wouldn't notice a change in rotation. So, here's a simple implementation that shows the ",(0,i.jsx)(t.strong,{children:"movement direction"})," of the objects with a little line. The higher the speed, the longer the line. This basically represents the ",(0,i.jsx)(t.strong,{children:"heading vector"})," of the object. You can easily add this visualisation to your drawing function."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"draw() {\r\n    // Other drawing operations\r\n    // ...\r\n\r\n    // Draw heading vector\r\n    this.context.beginPath();\r\n    this.context.moveTo(this.x, this.y);\r\n    this.context.lineTo(this.x + this.vx, this.y + this.vy);\r\n    this.context.stroke();\r\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"add-the-effects-of-gravity",children:"Add the effects of gravity"}),"\n",(0,i.jsxs)(t.p,{children:["The examples shown in this tutorial contain just a basic implementation of physics. You could add more aspects to your game to make it look even ",(0,i.jsx)(t.strong,{children:"more natural"}),". Things like ",(0,i.jsx)(t.strong,{children:"gravity"})," or ",(0,i.jsx)(t.strong,{children:"restitution"})," aren't too hard to implement. Let's start right now with adding gravity to your simulation."]}),"\n",(0,i.jsxs)(t.p,{children:["For ",(0,i.jsx)(t.strong,{children:"gravity"}),", simply adjust the y-speed of your objects with the ",(0,i.jsx)(t.a,{href:"https://www.physicsclassroom.com/class/1DKin/Lesson-5/Acceleration-of-Gravity",children:"gravitational acceleration"}),". On Earth, it's about ",(0,i.jsx)(t.em,{children:"9.81 meter per second per second"}),". You can apply it inside the ",(0,i.jsx)(t.code,{children:"update()"})," function of your game objects. Every second, g is added to the y-speed, this will make the object fall ",(0,i.jsx)(t.strong,{children:"faster and faster"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"// Set gravitational acceleration\r\nconst g = 9.81;\r\n\r\nupdate(secondsPassed){\r\n    // Apply acceleration\r\n    this.vy += g * secondsPassed;\r\n\r\n    // Move with set velocity\r\n    this.x += this.vx * secondsPassed;\r\n    this.y += this.vy * secondsPassed;\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Update the velocity before you update the position. This will give more accurate results, as explained in this article about ",(0,i.jsx)(t.a,{href:"https://gafferongames.com/post/integration_basics/",children:"integrating the equations of motion"}),". This type of integration is called ",(0,i.jsx)(t.strong,{children:"Semi-implicit Euler"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"confine-the-movement-space-of-the-objects",children:"Confine the movement space of the objects"}),"\n",(0,i.jsxs)(t.p,{children:["For the effects of gravity to show nicely, you can limit the movement of your objects to the edges of the canvas. It will act like ",(0,i.jsx)(t.strong,{children:"a closed box"})," on which the objects can bounce off."]}),"\n",(0,i.jsxs)(t.p,{children:["You can make it happen with a simple adjustment. Execute the next function right after your main collision detection function, so ",(0,i.jsx)(t.em,{children:"object-edge"})," collisions are checked together with the ",(0,i.jsx)(t.em,{children:"object-object"})," collisions."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"// Define the edges of the canvas\r\n const canvasWidth = 750;\r\n const canvasHeight = 400;\r\n\r\n // Set a restitution, a lower value will lose more energy when colliding\r\n const restitution = 0.90;\r\n\r\n function detectEdgeCollisions()\r\n {\r\n     let obj;\r\n     for (let i = 0; i < gameObjects.length; i++)\r\n     {\r\n         obj = gameObjects[i];\r\n\r\n         // Check for left and right\r\n         if (obj.x < obj.radius){\r\n             obj.vx = Math.abs(obj.vx) * restitution;\r\n             obj.x = obj.radius;\r\n         }else if (obj.x > canvasWidth - obj.radius){\r\n             obj.vx = -Math.abs(obj.vx) * restitution;\r\n             obj.x = canvasWidth - obj.radius;\r\n         }\r\n\r\n         // Check for bottom and top\r\n         if (obj.y < obj.radius){\r\n             obj.vy = Math.abs(obj.vy) * restitution;\r\n             obj.y = obj.radius;\r\n         } else if (obj.y > canvasHeight - obj.radius){\r\n             obj.vy = -Math.abs(obj.vy) * restitution;\r\n             obj.y = canvasHeight - obj.radius;\r\n         }\r\n     }\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It basically checks for objects positioned ",(0,i.jsx)(t.strong,{children:"beyond the edges"})," and resets their position to fall within the box again. The speed of the objects is then flipped to move ",(0,i.jsx)(t.strong,{children:"perpendicular"})," to the wall."]}),"\n",(0,i.jsxs)(t.p,{children:["It's a very basic implementation and only works this way because the edges of the canvas are ",(0,i.jsx)(t.strong,{children:"predefined straight lines"}),". You could do the same with a ",(0,i.jsx)(t.em,{children:"circle-line"})," collision and set-up dynamic lines, but that would be much more complicated than this quick example."]}),"\n",(0,i.jsx)(t.h3,{id:"absorb-impact-by-implementing-restitution",children:"Absorb impact by implementing restitution"}),"\n",(0,i.jsxs)(t.p,{children:["If you ran the code up till now, you'll see the game objects will never get in a resting state. They will keep bouncing and bouncing and never ",(0,i.jsx)(t.strong,{children:"lose any energy"}),". To counter this, you can implement ",(0,i.jsx)(t.strong,{children:"restitution"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Restitution basically describes how much ",(0,i.jsx)(t.strong,{children:"energy is left"})," after each collision. It has an effect on the bounciness of objects. The ratio between the ",(0,i.jsx)(t.strong,{children:"starting and ending velocity"})," after a bounce is called ",(0,i.jsx)(t.strong,{children:"coefficient of restitution"}),", or ",(0,i.jsx)(t.em,{children:"COR"}),"."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Objects with a ",(0,i.jsx)(t.em,{children:"COR"})," of ",(0,i.jsx)(t.em,{children:"0"})," would absorb all energy on impact, like a bag of sand hitting the floor."]}),"\n",(0,i.jsxs)(t.li,{children:["Objects with a ",(0,i.jsx)(t.em,{children:"COR"})," of ",(0,i.jsx)(t.em,{children:"1"})," would have perfect elasticity, like a super bouncy bouncing ball."]}),"\n",(0,i.jsxs)(t.li,{children:["Objects with a ",(0,i.jsx)(t.em,{children:"COR"})," > ",(0,i.jsx)(t.em,{children:"1"})," are completely fictional and would add extra energy after each collision."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["In the previous coding example, the ",(0,i.jsx)(t.em,{children:"COR"})," is being applied to the collision with the edges. This will make the objects lose just a little bit of ",(0,i.jsx)(t.strong,{children:"energy"})," after each bounce. It will make the simulation much more realistic, leaving it out would let the objects bounce on forever."]}),"\n",(0,i.jsxs)(t.p,{children:["To complete the implementation of the restitution, you'll need to apply it to the objects involved in an ",(0,i.jsx)(t.em,{children:"object-object"})," collision as well. Just multiply their speed by the ",(0,i.jsx)(t.strong,{children:"COR"})," (just ",(0,i.jsx)(t.code,{children:"restitution"})," in the code). Every collision will now use up a bit of energy."]}),"\n",(0,i.jsx)(t.p,{children:"When two objects collide with a different restitution setting, like for instance when a bouncing ball hits a bag of sand, the lowest restitution will count. In this case, neither the bouncing ball or the bag of sand will bounce, they both inherit the restitution of the bag."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"detectCollisions() {\r\n    // ...\r\n    // Calculate speed of the detected collision\r\n    let speed = vRelativeVelocity.x * vecCollisionNorm.x + vRelativeVelocity.y * vecCollisionNorm.y;\r\n\r\n    // Apply restitution to the speed\r\n    speed *= Math.min(obj1.restitution, obj2.restitution);\r\n    // ...\r\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The next live canvas example shows ",(0,i.jsx)(t.strong,{children:"gravity"}),", ",(0,i.jsx)(t.strong,{children:"restitution and boxing"})," being applied."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(6824).A+"",width:"600",height:"323"})}),"\n",(0,i.jsxs)(t.p,{children:["You can easily tweak the variables to create ",(0,i.jsx)(t.strong,{children:"different scenarios"}),". Set a high gravity to simulate being on a foreign planet or lower the restitution to make the objects act like bags of sand who absorb all impacts."]}),"\n",(0,i.jsx)(t.h3,{id:"ways-of-improving-performance",children:"Ways of improving performance"}),"\n",(0,i.jsxs)(t.p,{children:["You might not really notice it right now, but with many game objects on screen at once or with more complex shapes, the collision detection and reaction can put some serious stress on your system. Here are some tips that might help to ",(0,i.jsx)(t.strong,{children:"improve performance"}),". They might seem obvious, but when a game gets more complex it's easy to overlook some of these concepts."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Only compare objects that are close enough to have a possible collision. You could use a grid system or only detect collision when objects enter a certain radius. This is called splitting the collision detection into a ",(0,i.jsx)(t.strong,{children:"broad phase"})," and ",(0,i.jsx)(t.strong,{children:"narrow phase"}),". Learn more about ",(0,i.jsx)(t.a,{href:"http://buildnewgames.com/broad-phase-collision-detection/",children:"broad phase collision detection"})," here."]}),"\n",(0,i.jsxs)(t.li,{children:["Keep your ",(0,i.jsx)(t.strong,{children:"object pool"})," clean. Clean up objects when they are out of view or destroyed in-game."]}),"\n",(0,i.jsxs)(t.li,{children:["Exclude ",(0,i.jsx)(t.strong,{children:"background/stationary objects"}),". Some objects won't ever react to collisions, so don't include them in the iteration."]}),"\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.strong,{children:"hitboxes"}),". As explained before, hitboxes are a great way of optimizing collision detection and simplify complex shapes."]}),"\n",(0,i.jsxs)(t.li,{children:["Adjust the ",(0,i.jsx)(t.strong,{children:"implementation"})," of collision detection and physics to fit your game. You don't need a full physics engine when all you want to do is to make tic-tac-toe. That's a bit of a drastic example, but you get the point. Strip your logic to only support what is needed."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"handle-fast-moving-objects",children:"Handle fast-moving objects"}),"\n",(0,i.jsxs)(t.p,{children:["One final note about collision detection. The above example detects collisions by checking if two objects overlap. This is a good solution in many cases. But it won't work when your objects move at ",(0,i.jsx)(t.strong,{children:"great speed"}),". When the speed is higher than the size of your smallest object, objects have a chance of skipping the collision check. They ",(0,i.jsx)(t.strong,{children:"pass through"})," each other."]}),"\n",(0,i.jsx)(t.p,{children:"Imagine you check for a collision between a bullet and an enemy in your game. The first frame the bullet is before the enemy. There is no overlap, so the objects didn't hit. The next frame the bullet moved so fast, it is now behind your enemy. There still is no overlap, so no collision. But the bullet did pass right through the enemy and there should've been a hit."}),"\n",(0,i.jsx)(t.p,{children:"Here's an image to demonstrate the situation of a fast-moving object, like a bullet, that never has any real overlap with another game object but should've caused a collision:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:o(4017).A+"",width:"750",height:"317"})}),"\n",(0,i.jsxs)(t.p,{children:["You need another approach for this kind of situation. The simplest way is to ",(0,i.jsx)(t.strong,{children:"limit the speed"})," of your game objects. In short, make sure the speed is never larger than the smallest game object, so it can't pass through. For many types of games this is a great solution and it requires minimal effort."]}),"\n",(0,i.jsxs)(t.p,{children:["The other solution is to perform collision detection with the ",(0,i.jsx)(t.strong,{children:"projected path"})," instead of the current position of the two objects. Try to visualize the path of a bullet as a line. The length of the line is equal to the distance the bullet will travel. Now you can use a ",(0,i.jsx)(t.strong,{children:"line-to-rectangle"})," or ",(0,i.jsx)(t.strong,{children:"line-to-circle"})," collision check to find out if the bullet will hit another object. For large bullets, you could use a rectangle instead of a line."]}),"\n",(0,i.jsx)(t.p,{children:"This is a simplified solution. You will probably run into other problems along the way, like finding the point of impact or determining which object of a greater set is hit first. But the steps mentioned here might help to point you in the right direction. For now, this is all on fast-moving objects for this tutorial."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},4017:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-bullet-58b2e343f23f6c70e13954c74d5ff247.png"},869:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-circle-collision-a0070fb53251d529a76c84ad1c9aa429.gif"},8789:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-circle-2ad082618554bb36bb0d8a590e89164b.jpg"},7204:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-collision-detection-8d981246def5a942c4af7a16cac49511.gif"},218:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-collision-3be87efef066823e4c9320e4ca4c80e6.gif"},7490:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-dot-product-63dd9e8b14dc8d53f0ee0215eb4b5774.png"},2904:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-game-loop-ae41340452d8335b639bdeeaeb70312c.jpg"},6824:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-gravity-59adabc9509724372174c4fa382b8023.gif"},1939:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-hitboxes-86d64f3f75d9447e1bca56d5eb3c502d.jpg"},8306:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-mass-162126f33389e3843419fb987cd6863c.gif"},3190:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-objects-8e229a34ba76c8987d2bf450589687d7.gif"},9661:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-relative-vector-8081b422d859b167b3b075302af9aede.png"},18:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-vector-1-19030ae012550240a2a93c2b2d703d2c.jpg"},5949:(e,t,o)=>{o.d(t,{A:()=>i});const i=o.p+"assets/images/physics-vector-2-a4d053313656d7a692e8a68036e31d4b.jpg"},3728:(e,t,o)=>{o.d(t,{A:()=>i});const i="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gHYSUNDX1BST0ZJTEUAAQEAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADb/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCADjAUADASIAAhEBAxEB/8QAHQABAAEFAQEBAAAAAAAAAAAAAAcCBAUGCAMBCf/EAEUQAAEDAgIGBgcEBwgDAQAAAAEAAgMEBQYRBxIhMUFREyJhcYGhFCMyQpGxwVJictEIFSQzQ4KSFjVTk6KywuFUY/Bz/8QAHQEBAAEFAQEBAAAAAAAAAAAAAAYBAwQFBwIICf/EADcRAAIBAwEECAQFBAMBAAAAAAABAgMEEQUSITFBBhMiUWFxkdEygaGxFCNSwfAHFRbhM0Jykv/aAAwDAQACEQMRAD8A/VNERAEREAREQBEWGvmMLNhwEXC4QwPyz6LPWk/pGZ8lRyUVlsuU6c6stinFt9y3mZRRVddPdDCXNt1tmqTuD53iMfAZk+S1iu053+YnoYqKkbwyYXH4k/RYkrujHnkkNHo7qFZZcNnzf7b2T4i5ul004lJ/vaGPsbDF9QqodNOJQf7zgl7HQx/QBWvx9Luf8+Znf4pf4ztR9X7HR6KCKHTve4iPSKSjq2cdUOYfiCR5LarRp3tFWWtuFHUUDjve3KVg+GR8ldjd0Zc8GurdH9QorPV7S8Hn6cfoSaix9oxBbb/F0luroKxoGZ6J4Jb3jePFZBZaaayjQThKnJxmsNd4REVTwEREAREQBERAEREAREQBERAEREAREQBERAEREAREQBERAEREAWFxNi+14SpemuFQGOcPVws2ySdw+p2dq13SHpQp8JtdRUWpVXYja0nNkHIvy48m+J4Z874hxPPW1stRVzvra6Q5uc87vyHIBa64u40uzHeyZaP0dq6hirWzGHLvfsvH0JAxdpmut4EjKSQWeh3erd6xw7X8O5uXiowqr+0ucY2umeTmXyHIE/MrET1ElU/XleXngOA7gvNaCpXnUeZM69Z6XbWUNilFLy/d8WXU10qpt8pYOTNitnEvObiXHtOa+Isd7+JtlFR4Iao5BNUcgiIeipj3RnNjnN/Ccldw3eqiyzeJRyeM/NWSKqeOB5lGMviRsVtxL6POyVkslDUNObZY3EZHscNoUtYS03VtD0cN5Z+sKU7BUx5CVo7eDvI9pUBr3pa2WidnG7q8WO9krIpXE6TymaS+0e2vobNSOfv8nxR2zZr3Q4gom1dvqWVMDtmsw7WnkRvB7Cr5clYQxrWWOtFXbJzBOMukgdta8ciOI8x2Lo7A2PKLGtEXR5QV0Y9dSk5lv3hzb2/FSG3uo1tz3M47q+g1tNbnHtQ7+a8/c2dERZxFgiIgCIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgCIiALQdKOkQYUo/QKF4N3nZmDv6BhzGv37DkOzM8jsmLsTQYTsVRcJsnOaNWKMn9487m/XuBXKuJ8QVFXVz1c8hkrqpxe554dvhuAWuvLjqo7MeLJl0d0f+4VeuqrsR5d79lzLK83l/SyNZI59Q8l0srjmQTv28T2rBIijLbk8s7jTpxpR2YhERULoREQBERAEREAREQH1rnRvD2OLXjaHDeFteGMTVNDWw1VLKaavgOsHN3OHHZxHMLU1Ux7ontexxa9pzBC9Rk4vKMevQhXg4yR2PgXGtPjS0idgEVXFk2ogHuu5j7p4fDgtlXJ+BsZT4eudPdKbMlh1KinByEjTvb9R2gLqe23Gnu9BBWUsglp52B7HjiCpTa3HXR38UcG13SXplfMF2JcPB93t4eRcoiLNIwEREAREQBERAEREAREQBERAEREAREQBERAERYbGF8GHMNXC4AgSRRkR58XnY3zIVG1FNsuUqcq0404cW8L5kKaZcXC8YgkpWSfsNuBZsOx0nvnyy8DzUM1E7qqZ8r97uHIcAsviCrcWNjLi58pL3knMn/wCKwiiFeo6k22fRml2cLK2jThyWPd/NhERY5uAiIgCIiAIiIAiIgCIiAIiIC6t1X6HVNcT6t3Vf3c/BdBaDMVEST2Gd+bSDPTZ/62/X4rnPetuwffprVU0VwizdPRyg5De4Dh4jYsu2qulNMjuuWEb+1lT5vh58vbyOwEXlS1MdbTQ1ELxJDKwSMcNxaRmD8F6qWnz0008MIiIUCIiAIisK2/2y2kiruNLTEcJZmtPmVRtLie4wlN4issv0WtyaR8MxHJ15pj+El3yCpZpKwxIcheKcfizHzC8dbD9S9TK/A3WM9VL/AOX7GzIsXR4os9wIFNdaOYn3WTtJ+GayYOYXtNPgY06c6bxNNeZ9REVS2EREAREQBERAFFWnu6mG1W23NdtnldM8Dk0ZDzd5KVVAenOuM2Loos+pTUrdnaSXHyyWHdy2aL8SS9HaPXahBv8A65f8+bIXukvTV8p3hp1B4K1X0u1yXcySviibed59AxWykgiIh6CIiAIiIAvoGZyG9fFq+lYyN0V41dEXCUWOuLSz2gfR35ZZcVWKy0i1Vn1VOU8cE2bSGku1QDrclpWPtK1rwFX221egXLEOI7mHPo7FZIBNVSRtOTpXZkNjjB3ucRuOWeRyiXH9bNH+hXgyoNQ9s8tFh0Nl1yHPeZKckA7ycg4+BW34eypv0wNIkVdqitrcP0D7SHe0+lY4idrOeUgBIHLNZUaKScnvxn6Y9zRVdRnOUKNLsuWzv442lJ8O/s4Xi0bVg3Sa/FF8nstywliHCV2jpzVMivFOzoZ4w4NcY543OY4gubm3MHbx2rdV9e7oiyN7gxz83NY45F2W8gccsxt7V8WNJpvKWDd0YzhHZnLaffw+wREXkvhZKxS6lU+Pg9ufiFjVcW+To66B3DWyPiqp4ZbqR2oNHWOiC6m6YHpGudrPpXup3eG0eRC3VRHoArc6a8UhPsvjla3vBBP+kKXFL7eW1Siz511miqGoVYLvz67/ANwi+E5BRdjrTLFbnSUNi1KmpGbX1Z60bD90e8e3d3r3UqxpLMmYlnZV76p1dCOX9F5s3++YktuG6bp7jVx0zD7LXHNz/wALRtPgouxDp4keXxWWhDW/+RV7T3hg3eJ8FDt8xRLWVkk9TUPr6156z3uz8CfoFr9TXz1WevIQ37DdgWkrX8pbobjqOndEqFNKdx239PTn8/Q3m+6R7pdHOFdeZ5Ad8MTtVv8AS3ILWJL/ABAnUie/tJAWFAyRayVWUnlsnFGxoUI7MI4Xhu+xlTf38IGjvcUF/k4wMP8AMVikXjafeZPUU+4zLL+w+3C4drXArO2THlZanNFBdqijy/hl5DD/ACnqlaSi9RqSi8plirZUasdmSyvX7k/Yf063GlLGXaljr4f8aDJknf8AZPkpSw1jaz4sj/YKoGYDN1PJ1ZW/y8e8ZhcaU9VLSnOKQs7N4PgszbsQ6k0bnOdTTMILZo3EZHgc94WxpX847pbyGah0Ttq6cqC2H4cPT2O0EULYH00y05io7+TPAcg2uaM3N/GB7Q7Rt71MlNUxVkEc8ErJoZGhzJI3ZtcOYK3lKtCssxOV32nXGnT2Ky3cnyZ6oiK+awIiIAubtNMhOOLt92KMD/KafqukVzhpphIxxc//AGQxkf5YH0Wuvv8Ai+fuTPopj8fLP6X94kQN3BEb7IRRg7qEREAREQBERAQxpI0n3tuOH4YsM4tsNJGH1daImySlxbrardbYAAW8MyT2LLYD0j1UtNUW/Fk9LVZjVirGQ6omYRk5kseWWfaNhB25cfPSfoUmxhfBfLLc2Wy5vY1k7Jg7o5dXYHAt2h2Ww7CDkF7WLQxLTWborteX11zLtbp4og2Ngy9nI7Xd5IUvs56NO1VK7TU/1Liv55M4LrNt0/o61UvNHlCpRSf5c3iMll4xvW/DS4x3rfnnYUf6Nmja4UbImMudxtUMrZqGgkvU8tJbnh4f+zR62rHmRkd5yJGYBK3bH+jLDmk1tG6/UUklZQyOlorjRzvpquked5imYQ5oPEbQchs2LSqvR5frFKZrfMZgNz6d5Y8Du+gJSj0jX2yS9BcIOn1d7J2FjwO/6kFZEtClc/madcqrjlnEl8vfBgUf6iW+kP8AC9KdJnaOWE5KO3TePFJcOWzt47zZ8F6IsOaP7pU3ijdc7je5qf0WS7Xu5S1tT0OtrdGHPOTW6wBIAGeQz3K1wrpCbWXyqo6t/qZ5iaaR3ugnY0+Xj3ryumlCiuGH6yOJktPWyR6jWOGY27CQRyBO/JRgHEHPPatppHR6VejXWoQcZPCWeKxvyvp4PeiIdN/6n0NNvtOn0ZrRnShtTml8Mtrs7ElxTwpPespuMu46URaVo8xn+uqcUNW/9tib1XOP71vPvHH481uqgV7Z1bCvK3rLevqu9eDPpfQNdsukmnU9SsJZhPlzi+cZLk1/tZTTCriOU0Z5OHzVCrhGtPEObx81gkgfAn7QI8i+3VnA04OXc7/tTW97Y2Oc5wa1ozLicgAoV0Bxl15u0nBsDW/F3/S99MekEySSWC3y6sbNlZK05Zn/AAweQ4/DgVJaFVUbdSZxDU7GpqOsSo0+5ZfcsLeY7SdpUfeXTW21zGG2NzE1QDkZ+e3g359yhi4XZ1RnHCSyLcXbi78gqLncfTH9HGcoGn+o8+5WK0datKrLLOrabplHT6Kp04/zvfj9huREWMboIiIAiIgCIiAIiIC7oblJREN9uHizl3KUtHGkyfCszGuc6qs8p68Oe2M8XN5HmOPmoiVzQ1r6GXWGbo3e2zn296vUqsqUk0zV31hRvqUqdSOc/wA9fE7doK+nulHDV0krZ6eVusyRh2EK4XPGinSJ/ZqtZS1U2tZqojNxOyF32x2cCPHht6GBzGY2hSqhWVaOVxOCarptTTK/Vy3xfB9/+1zPqIiyDTBQTp3oeixRR1GWTailDSeZa4g+RCnZRlp2tBq8PUde1ubqSbVcctzHjL5hvxWHdx2qL8CRdH6yo6hTzwllevD64OYHsMb3MO9pIVKvbvD0Ve85bH9cfVWSijWNx9CRltRUgiIqHoIiIAiIgCIiAK3rLfTXCLo6mCOeP7MjQ4eauEOwL1GTg1KLw0W6lKnWg6dWKlF8U1lPzTIY0j2m22a6QwUERicWa8jdYkbTs39x+IWordb3he+Yov8AV1cdFIyJ7yGOmIZ1RsGw5HcBuV3Q6Ia2TI1VZDAOIjaXnzyXb7XVLOxs6cLq4Tmks79p54vOMvdwPzx1nodrnSPXLq40bTJQoSm9jEVThsrcmtrZjvS2njm2aJSVUtFURzwPMcsZ1mubvBU4YOxVFia3BxIbVxjKaMc+Y7CsTRaJ7TT5GeSepPEF2q3y2+a2S14bttldrUdIyF+WrrjMuy5ZnbwUO6QavpupUlGmpOceEsYXinl5x8uJ3b+mfQjpZ0TvJVbqdONvU+OntOUs8pLCcVJf+t63Pk1klc22PpK+AcA7WPgrZZSww600svBo1R3lQBLLPperLZg2S3gm/nBuCL1c48vTKydlJTZ/aa0ku7gH59+Q4qK79cHOLodcukk60rycyc+3tWbuN1Jt1PE4/s9IxxDebnHNx8dg8AtLkkdLI57zm5xzKyq1RuKguCNFp1moValxJdqTz6bkvkt/mylERYhIgiIgCIiAIiIAiIgCIiAIiIDI2at6GXoHn1bz1ex3/a6U0MYwN3tBtFU/Wq6FoEZdvfFuH9OwdxC5aW+YDxTJZLtQXRhJMLw2do95u5w8Rt71nWlbqpruIp0g0xX9rJJdrivP/fA6yRUQzMqIY5Y3B8b2hzXDcQdoKrUqOBtY3MLH4gtDL9ZK23yZBtREWAn3TwPgcj4LIIqNJrDPUJypyU4vet5xniW2y0/SslYWT0ryyRp3jI5EeBWuqfNN2EvQbmy8wx501Z1JwBsbJlv/AJh5g81BVbSmiqHR+7vYeYURuKTpTaZ9EaPfQvraNSPP7818meCIixjehERAEREAREQBERAEREAREQBbPa6J0VIGBvXDTI/s/wDtiw1po/SajXcM4o9p7TwCkiazmz4CbcJm5VF1qRHEHDaIWAuLue12r4Ac1kUoOWX3Gnv7mNLZp820v55LLNCv0+rFHCPeOse4bvNYZXt4k6SvkHBgDVZKzJ5ZsaMdmmgiIvJfCIiAIiIAiIgCIiAIiIAiIgCyVjn1Kl8R3SDMd4WNXrSy9BUxSfZcFVPDyW6kduDidZaH72bvgunje7Wlo3Gnd3Da3yIHgt3ULaArgWXK60Jd1ZImzNHa05H/AHD4KaVLrae3Siz531u3Vtf1Irg3n13/AHCIiyTRlje7NTYgtVTb6tmvBO3VPNp4EdoOR8FyxjTCNTZLjPbKsas8R1opcuq9p3OHYfI9y61Wr49wNTY1tgjcWw10IJp6gj2Sd7T905D5rBurfro5XFEq0HV3ptbZqP8ALlx8H3+/h5HHb2Oje5jgWuaciDwVK2zE+GKmhrZqWqhNNXwHVIducOG3iORWqvY6J7mPaWPbvaeCi8ouLwzu1CvCvBSiylEReTICIiAIiIAiIgCIiAL0p6d9VM2KMZuPHgBzKU9PJVSiOJus7ieAHMresFYKqsQV7KCgZrOOTpqhw6rG8z2chxVyEHN4Rh3V1TtabnN4x9DKaNcBuxTdY6VrXNt1Pk+plGwkcgftOy8BmeC3PTy5sNRY6KJojhiieWsaMg0ZtAy8GqVMM4bo8K2mKgo25Mb1nvPtSO4uPaom095/r+1cvRz/AL1vZ0VQt2ubwcottTeqazCX/SKlj0e9+LIEqna9VM7m8/NeSqk/eyfiPzVKjx2JbkEREKhERAEREBYXu/23DVvfXXWthoKRpDTLO7IEncBxJ7ArbDeMbJjCGWWzXOC4NiIEgiJDmZ7s2nIj4KFP0oYK1t1w/Uya36pEMkbHe42cuBOfIluWXcVrH6P8NZPpPpJKLWMMMEvpr2+yIi3Y13e7VyHYtpGzjK367a38SA1+kdelrC05UuzlR55343rlhZ7uC4nVSIi1ZPgiIgCIiAIdxRDuKAmbQlVGPG1KAf39O9h7errf8V0QubdC+f8Abiz/AP5yZ/5Tl0kpPYv8r5nCelUVG/WP0r7sIiLYkNCIiA1rGuBKDGlFqTgQVkY9TVNbm5nYebez5LnXGWBK3D1X6Nc6csJz6Kqj2sePun6HaF1era422lu9JJS1tPHU07/ajkbmO/sPasKvaxrb+DJPpOu19Nag+1Du5ry9uBxJV26ajJLhrx/bbu8eStV0ZirQY4OfUWGcFp2+h1Dtvc1/0d8VEV+wdPa6gxV9FNb5+BLdUO7RwPeFH6ttOk96Ov2GuWt/HsS393P09txqCLJS2KZn7t7JB29Uq1fb6mP2oH5cwM1itNG+jUhLgy3RVmKQb43j+UoIZHbo3nuaVQ95RQiuY7bVSboHAc3bAruGwyO2yytYOTNpVUmy3KrCPFmLV9R2mapyc/OGLmR1j3BbbhrAdfepQLZbZak55Gdw6je9x2BTDhPQhSULmVN7lFdMNvo0eYiB7Tvd5DvWZRtZ1eC3Ec1HX7WxTUpdruW9+nL5kbYD0a12KJGimjNJbmu9ZVyDMHmB9o+Q45LoXDeGaDCltbR0EWoze+R218jubjxKycMMdPEyKJjYomDVaxgyDRyA4KtSChbQoLdxOP6prNfU5Yluh3fu+9hQ1p/pi2qs1RlscyRmfcWn6qZVHOnO2mqwlFVtG2kqGl34XdX5lqrdR2qMjzoVVUtRpN83j1TX3OXKtnR1czeTyvJX15j6OvceDwHfmrFRJ7mfQ8HtRTCIioewiIgCIiA8ayiprjSyU1XTxVVPIMnwzMD2O7wdi8bVZbfYqY09toaeggJ1jHTRBgJ5nLerxFXLxgtunBz6xxW138wiIqFwIiIAiIgCEZghF7UkXT1cLObhn3b0KN4WSYtCVKZMa05H8Gme4/AN/wCS6GUNaArcXVd3ryMgGMgaeeZLj8h8VMqlVnHZpLxOBdJaqqahJfpSX7/uERFnEVCIiAIiIAvKqpIK2F0NRDHURO3xytDmnwK9UQqm08o0q66IMNXMuc2kfQyH3qWQtH9JzHktYrNAEJJNJeHs5NmgDvMEfJS4ixpW9KXGJuaOs6hQWIVX89/3yQlJoEuYPUutK4cNZrh+a+x6A7iT6y7UzR91jnfkpsRW/wAHR7jM/wAj1HHxr0XsRRRaAaNhBq7tPMOIhiEfmS5bVaNFmGrQWuZbm1Mo9+qcZPI9XyW2orsbelDhEwK2r39wsVKrx4bvtgpjjbExrGNDGNGQa0ZABVIiyDUBERAFjMTWgX/D9fbzsM8LmtJ4O3tPxAWTRUaTWGe6c5U5qceKeTi3EFK9sbXuYWSRO1HtO8dngVg1M2mXCotGJZpmsyork0yAgbA/3x8cj/MocmhdTyvif7TDke1Q+vTdObiz6O0u7heW0aseaz7r5PcUIiKwbcIiIAiIgCIiAIiIAiIgCIiALJ2KDWmkmI2MGqO8/wDSxmROwDMnYAOKkPR5hN1+vVBbACYy7pKhw4MG135DwV2nBzkkjAvriFvQlObwkvouJPWieyGy4LpNdurNVE1LwRt63s/6Q1biqWMbGxrGANa0ZADcAqlMIRUIqK5Hzfc15XNadaXGTbCIi9mMEREAREQBERAEREAREQBERAEREAREQBERAa7jzCbMYYemo+q2pZ6ynkd7rx9DtB71ylf7XKxz3PidFUwEslicOsMjtB7QV2eon0w6PnVjZL/bYi6oaB6XEwZl7QMg8DmAMj2DsWrvbfrI7ceKJ10Z1f8AB1fw1V9mT3eD7vJ/fzOaUWRutu6AmeIepO1wHun8ljlHGsbjtcJqa2kERFQ9hERAEREAREQBERAERXdvt7q6TM5thaes7n2BVSyeZSUVllzZaLXf6S8dVvsA8Tz8F03ohwYcOWQ11VHq19aA4gjbHH7re87z4clo2iLR3+uamK7VsWrbKd3qYnDZM8f8R5nZzU8Lf2NvsrrJfI5B0p1jrpOzpP8A9fsv3YREW4OcBERAEREAREQBERAEREAREQBERAEREAREQBERAEREBDWkzROYTLdrHDnEc3T0LG+zzcwcubfhs2CC6+zlpMlMM28YhvHd+S7ZUe470R0eJHSVttcyguTjrOBHqpj94Dce0eIO9ai5stvtU/Q6JonSaVvihdvdyl7+5ymi3TE+Daq0VZgudJJRVJ9l+Wx45g7nDuWr1NqqKfM6vSs+0zb5LQyhKLw0dZo3VKvFSg+P83Ms0Tjlx5IvBlhERAERCckATcrmnt9RVbWRkN+2/YFnrLhiSrq44KeCSvq3nqsYzP4D6leoxcuBj1a9Okm5PgYegtT6rKSXOOH4F3d+alzRtorlxIYaytjdSWZmRa0DJ1QOTeTebuPDmNrwRoWZSvjrcQas8oyc2iac2NP3z73cNnepXa0MaGtAa0DIADIALeW1ljtVPQ5brfSjazRs3v8A1cl5d78fQop6eKkgjhhjbFDG0NYxgyDQNwAXoiLdHMm23lhERCgREQBERAEREAREQBERAEREAREQBERAEREAREQBERAEREBa3G2Ul3pXU1bTR1UDt7JWhw7+w9qjbEGgmiqXOls9W+iedognzfH3A7x45qU0VmpShU+JGwtNQurJ5oTa8OXpwOZ77ojv9vLumtXp0Y/i0vrM/Adb4haZWYZbTSak0M9K/wCy8EH4ELstUSwRzt1ZY2yN5PaCFgT0+D+Fkvt+mFzTWKsE/Jte5xabAz3Z3eLQvgsDeM7vBoXYcmGLNMc5LTQvPN1Mw/RUswrZIzmyz0Dfw0rB9FY/tvibT/NFj/jfqvY5Fgw7FI8Nb007jua3efALbLJotvdxc00tlliaf4tQ3oxlzzdln4Lp2npIKRuUEMcI5RsDfkvZXo6fFfEzXXHTGvNYpU8ebz9Fgh+w6BtrZLzcM+cFJ9XuHyHipOsmHLbhym6C20cVKw+0WDrO73HafFZJFn06NOl8KIjd6nd326tPK7uC9AiIr5qwiIgCIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgCIiAIiIAiIgP//Z"},8453:(e,t,o)=>{o.d(t,{R:()=>a,x:()=>r});var i=o(6540);const s={},n=i.createContext(s);function a(e){const t=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(n.Provider,{value:t},e.children)}}}]);