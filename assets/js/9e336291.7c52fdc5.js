"use strict";(self.webpackChunkfresher_training_doc=self.webpackChunkfresher_training_doc||[]).push([[757],{388:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=t(4848),a=t(8453);const i={},o="Image Processing",s={id:"WebGL/webgl-image-processing",title:"Image Processing",description:"To draw images in WebGL we need to use textures. Similarly to the way WebGL expects clip space coordinates when rendering instead of pixels, WebGL expects texture coordinates when reading a texture. Texture coordinates go from 0.0 to 1.0 no matter the dimensions of the texture.",source:"@site/docs/WebGL/webgl-image-processing.md",sourceDirName:"WebGL",slug:"/WebGL/webgl-image-processing",permalink:"/fresher-training-doc/docs/WebGL/webgl-image-processing",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/WebGL/webgl-image-processing.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"How it works",permalink:"/fresher-training-doc/docs/WebGL/webgl-how-it-works"}},l={},c=[{value:"Image effects",id:"image-effects",level:3}];function g(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"image-processing",children:"Image Processing"})}),"\n",(0,r.jsx)(n.p,{children:"To draw images in WebGL we need to use textures. Similarly to the way WebGL expects clip space coordinates when rendering instead of pixels, WebGL expects texture coordinates when reading a texture. Texture coordinates go from 0.0 to 1.0 no matter the dimensions of the texture."}),"\n",(0,r.jsx)(n.p,{children:"Since we are only drawing a single rectangle (well, 2 triangles) we need to tell WebGL which place in the texture each point in the rectangle corresponds to. We'll pass this information from the vertex shader to the fragment shader using a special kind of variable called a 'varying'. It's called a varying because it varies. WebGL will interpolate the values we provide in the vertex shader as it draws each pixel using the fragment shader."}),"\n",(0,r.jsxs)(n.p,{children:["Using the ",(0,r.jsx)(n.a,{href:"/fresher-training-doc/docs/WebGL/webgl-funamentals",children:"vertex shader from the end of the previous lesson"})," we need to add an attribute to pass in texture coordinates and then pass those on to the fragment shader."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"attribute vec2 a_texCoord;\n...\nvarying vec2 v_texCoord;\n \nvoid main() {\n   ...\n   // pass the texCoord to the fragment shader\n   // The GPU will interpolate this value between points\n   v_texCoord = a_texCoord;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Then we supply a fragment shader to look up colors from the texture."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"precision mediump float;\n \n// our texture\nuniform sampler2D u_image;\n \n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\n \nvoid main() {\n   // Look up a color from the texture.\n   gl_FragColor = texture2D(u_image, v_texCoord);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we need to load ",(0,r.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(2234).A+"",children:"Mr Survivor image"}),", create a texture and copy the image into the texture. Because we are in a browser images load asynchronously so we have to re-arrange our code a little to wait for the texture to load. Once it loads we'll draw it."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'var image = new Image();\nimage.src = "./mr-survivor.jpg";\nimage.onload = function() {\n    render(image);\n}\n \nfunction render(image) {\n    ...\n    var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");\n    \n    // Create a buffer to put three 2d clip space points in\n    var positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    setRectangle(gl, 0, 0, image.width, image.height);\n\n\n    // Create a texture.\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    // Set the parameters so we can render any size image.\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n    // Upload the image into the texture.\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\n    // Create view port\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    // Clear the canvas\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Tell it to use our program (pair of shaders)\n    gl.useProgram(program);\n\n    // Set the resolution\n    gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n\n\n    // Turn on position attribute\n    gl.enableVertexAttribArray(positionAttributeLocation);\n\n    // Bind the position buffer.\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n    var size = 2;          // 2 components per iteration\n    var type = gl.FLOAT;   // the data is 32bit floats\n    var normalize = false; // don\'t normalize the data\n    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\n    var offset = 0;        // start at the beginning of the buffer\n    gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset)\n\n    // Turn on the texcoord attribute\n    gl.enableVertexAttribArray(texcoordLocation);\n\n    // Bind the texcoord buffer.\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n\n    // Tell the texcoord attribute how to get data out of texcoordBuffer (ARRAY_BUFFER)\n    var size = 2;          // 2 components per iteration\n    var type = gl.FLOAT;   // the data is 32bit floats\n    var normalize = false; // don\'t normalize the data\n    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\n    var offset = 0;        // start at the beginning of the buffer\n    gl.vertexAttribPointer(texcoordLocation, size, type, normalize, stride, offset);\n    \n    // Draw the rectangle.\n    var primitiveType = gl.TRIANGLES;\n    var offset = 0;\n    var count = 6;\n    gl.drawArrays(primitiveType, offset, count);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(5175).A+"",width:"399",height:"299"})}),"\n",(0,r.jsx)(n.p,{children:"Let just swapping red and blue and see what happens."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"gl_FragColor = texture2D(u_image, v_texCoord).bgra;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(3687).A+"",width:"398",height:"299"})}),"\n",(0,r.jsxs)(n.p,{children:["What if we want to do image processing that actually looks at other pixels? Since WebGL references textures in texture coordinates which go from 0.0 to 1.0 then we can calculate how much to move for 1 pixel with the simple math ",(0,r.jsx)(n.code,{children:"onePixel = 1.0 / textureSize"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Here's a fragment shader that averages the left and right pixels of each pixel in the texture"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"precision mediump float;\n \n// our texture\nuniform sampler2D u_image;\nuniform vec2 u_textureSize;\n \n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\n \nvoid main() {\n   // compute 1 pixel in texture coordinates.\n   vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\n \n   // average the left, middle, and right pixels.\n   gl_FragColor = (\n       texture2D(u_image, v_texCoord) +\n       texture2D(u_image, v_texCoord + vec2(onePixel.x, 0.0)) +\n       texture2D(u_image, v_texCoord + vec2(-onePixel.x, 0.0))) / 3.0;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"We then need to pass in the size of the texture from JavaScript."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'...\n\nvar textureSizeLocation = gl.getUniformLocation(program, "u_textureSize");\n\n...\n\n// set the size of the image\ngl.uniform2f(textureSizeLocation, image.width, image.height);\n\n...\n\n'})}),"\n",(0,r.jsx)(n.p,{children:"Compare to the un-blurred image above."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(7307).A+"",width:"1195",height:"898"})}),"\n",(0,r.jsx)(n.h3,{id:"image-effects",children:"Image effects"}),"\n",(0,r.jsxs)(n.p,{children:["Now that we know how to reference other pixels let's use a ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Kernel_(image_processing)",children:"convolution kernel"})," to do a bunch of common image processing. In this case we'll use a 3x3 kernel. A convolution kernel is just a 3x3 matrix where each entry in the matrix represents how much to multiply the 8 pixels around the pixel we are rendering. We then divide the result by the weight of the kernel (the sum of all values in the kernel) or 1.0, whichever is greater. ",(0,r.jsx)(n.a,{href:"https://docs.gimp.org/2.10/en/gimp-filter-convolution-matrix.html",children:"Here's a pretty good article on it"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"In our case we're going to do that work in the shader so here's the new fragment shader."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"precision mediump float;\n \n// our texture\nuniform sampler2D u_image;\nuniform vec2 u_textureSize;\nuniform float u_kernel[9];\nuniform float u_kernelWeight;\n \n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\n \nvoid main() {\n   vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\n   vec4 colorSum =\n     texture2D(u_image, v_texCoord + onePixel * vec2(-1, -1)) * u_kernel[0] +\n     texture2D(u_image, v_texCoord + onePixel * vec2( 0, -1)) * u_kernel[1] +\n     texture2D(u_image, v_texCoord + onePixel * vec2( 1, -1)) * u_kernel[2] +\n     texture2D(u_image, v_texCoord + onePixel * vec2(-1,  0)) * u_kernel[3] +\n     texture2D(u_image, v_texCoord + onePixel * vec2( 0,  0)) * u_kernel[4] +\n     texture2D(u_image, v_texCoord + onePixel * vec2( 1,  0)) * u_kernel[5] +\n     texture2D(u_image, v_texCoord + onePixel * vec2(-1,  1)) * u_kernel[6] +\n     texture2D(u_image, v_texCoord + onePixel * vec2( 0,  1)) * u_kernel[7] +\n     texture2D(u_image, v_texCoord + onePixel * vec2( 1,  1)) * u_kernel[8] ;\n \n   // Divide the sum by the weight but just use rgb\n   // we'll set alpha to 1.0\n   gl_FragColor = vec4((colorSum / u_kernelWeight).rgb, 1.0);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"In JavaScript we need to supply a convolution kernel and its weight"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:' function computeKernelWeight(kernel) {\n   var weight = kernel.reduce(function(prev, curr) {\n       return prev + curr;\n   });\n   return weight <= 0 ? 1 : weight;\n }\n \n ...\n var kernelLocation = gl.getUniformLocation(program, "u_kernel[0]");\n var kernelWeightLocation = gl.getUniformLocation(program, "u_kernelWeight");\n ...\n var edgeDetectKernel = [\n     -1, -1, -1,\n     -1,  8, -1,\n     -1, -1, -1\n ];\n gl.uniform1fv(kernelLocation, edgeDetectKernel);\n gl.uniform1f(kernelWeightLocation, computeKernelWeight(edgeDetectKernel));\n ...\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(603).A+"",width:"401",height:"301"})}),"\n",(0,r.jsx)(n.p,{children:"Here are a few more kernel effects"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"  var kernels = {\n    normal: [\n        0, 0, 0,\n        0, 1, 0,\n        0, 0, 0\n    ],\n    gaussianBlur: [\n        0.045, 0.122, 0.045,\n        0.122, 0.332, 0.122,\n        0.045, 0.122, 0.045\n    ],\n    unsharpen: [\n        -1, -1, -1,\n        -1,  9, -1,\n        -1, -1, -1\n    ],\n    emboss: [\n        -2, -1,  0,\n        -1,  1,  1,\n        0,  1,  2\n    ]\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["How about applying multiple effects? It could be done by generating shaders on the fly. Provide a UI that lets the user select the effects he wants to use then generate a shader that does all of the effects. That might not always be possible though that technique is often used to ",(0,r.jsx)(n.a,{href:"https://www.youtube.com/watch?v=cQUn0Zeh-0Q",children:"create effects for real time graphics"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"A more flexible way is to use 2 more textures and render to each texture in turn, ping ponging back and forth and applying the next effect each time."}),"\n",(0,r.jsx)(n.p,{children:"Original Image  -> [Blur]            ->     Texture 1\nTexture 1       -> [Sharpen          ->     Texture 2\nTexture 2       -> [Edge Detect]     ->     Texture 1\nTexture 1       -> [Blur]            ->     Texture 2\nTexture 2       -> [Normal]          ->     Canvas"}),"\n",(0,r.jsx)(n.p,{children:"To do this we need to create framebuffers. In WebGL and OpenGL, a Framebuffer is actually a poor name. A WebGL/OpenGL Framebuffer is really just a collection of state (a list of attachments) and not actually a buffer of any kind. But, by attaching a texture to a framebuffer we can render into that texture."}),"\n",(0,r.jsx)(n.p,{children:"First let's turn the old texture creation code into a function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function createAndSetupTexture(gl) {\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    \n    // Set up texture so we can render any size image and so we are\n    // working with pixels.\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    \n    return texture;\n}\n\n// Create a texture and put the image in it.\nvar originalImageTexture = createAndSetupTexture(gl);\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n"})}),"\n",(0,r.jsx)(n.p,{children:"And now let's use that function to make two more textures and attach them to 2 framebuffers."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// create 2 textures and attach them to framebuffers.\nvar textures = [];\nvar framebuffers = [];\nfor (var ii = 0; ii < 2; ++ii) {\n    var texture = createAndSetupTexture(gl);\n    textures.push(texture);\n    \n    // make the texture the same size as the image\n    gl.texImage2D(\n        gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0,\n        gl.RGBA, gl.UNSIGNED_BYTE, null);\n    \n    // Create a framebuffer\n    var fbo = gl.createFramebuffer();\n    framebuffers.push(fbo);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    \n    // Attach a texture to it.\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now let's make a set of kernels and then a list of them to apply."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Define several convolution kernels\nvar kernels = {\n    normal: [\n      0, 0, 0,\n      0, 1, 0,\n      0, 0, 0\n    ],\n    gaussianBlur: [\n      0.045, 0.122, 0.045,\n      0.122, 0.332, 0.122,\n      0.045, 0.122, 0.045\n    ],\n    unsharpen: [\n      -1, -1, -1,\n      -1,  9, -1,\n      -1, -1, -1\n    ],\n    emboss: [\n       -2, -1,  0,\n       -1,  1,  1,\n        0,  1,  2\n    ]\n};\n\n// List of effects to apply.\nvar effectsToApply = [\n    "gaussianBlur",\n    "emboss",\n    "unsharpen"\n];\n'})}),"\n",(0,r.jsx)(n.p,{children:"And finally let's apply each one, ping ponging which texture we are rendering too"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// start with the original image\ngl.bindTexture(gl.TEXTURE_2D, originalImageTexture);\n\n// loop through each effect we want to apply.\nfor (var ii = 0; ii < effectsToApply.length; ++ii) {\n    // Setup to draw into one of the framebuffers.\n    setFramebuffer(framebuffers[ii % 2], image.width, image.height);\n\n    drawWithKernel(effectsToApply[ii]);\n\n    // for the next draw, use the texture we just rendered to.\n    gl.bindTexture(gl.TEXTURE_2D, textures[ii % 2]);\n}\n\n// finally draw the result to the canvas.\nsetFramebuffer(null, canvas.width, canvas.height);\ndrawWithKernel("normal");\n\nfunction setFramebuffer(fbo, width, height) {\n    // make this the framebuffer we are rendering to.\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n\n    // Tell the shader the resolution of the framebuffer.\n    gl.uniform2f(resolutionUniformLocation, width, height);\n\n    // Tell webgl the viewport setting needed for framebuffer.\n    gl.viewport(0, 0, width, height);\n}\n\nfunction drawWithKernel(name) {\n    // set the kernel\n    gl.uniform1fv(kernelLocation, kernels[name]);\n    gl.uniform1f(kernelWeightLocation, computeKernelWeight(kernels[name]));\n\n    // Draw the rectangle.\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(9348).A+"",width:"399",height:"299"})}),"\n",(0,r.jsxs)(n.p,{children:["Calling ",(0,r.jsx)(n.code,{children:"gl.bindFramebuffer"})," with ",(0,r.jsx)(n.code,{children:"null"})," tells WebGL you want to render to the canvas instead of to one of your framebuffers."]}),"\n",(0,r.jsxs)(n.p,{children:["WebGL has to convert from clip space back into pixels. It does this based on the settings of ",(0,r.jsx)(n.code,{children:"gl.viewport"}),". Since the framebuffers we are rendering into are a different size than the canvas we need to set the viewport appropriately when rendering to the framebuffer textures and then again when finally rendering to the canvas."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"But why the image flipped?"})," It's because WebGL displays the canvas with 0,0 being the bottom left corner instead of the more traditional for 2D top left. That's not needed when rendering to a framebuffer. Because the framebuffer is never displayed, which part is top and bottom is irrelevant. All that matters is that pixel 0,0 in the framebuffer corresponds to 0,0 in our calculations. To deal with this I made it possible to set whether to flip or not by adding one more input into the shader."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"...\nuniform float u_flipY;\n...\n\nvoid main() {\n...\n\n    gl_Position = vec4(clipSpace * vec2(1, u_flipY), 0, 1);\n\n...\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"And then we can set it when we render with"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'    ...\n \n    var flipYLocation = gl.getUniformLocation(program, "u_flipY");\n \n    ...\n\n    // don\'t y flip images while drawing to the textures\n    gl.uniform1f(flipYLocation, 1);\n \n    ...\n \n    // need to y flip for canvas\n    gl.uniform1f(flipYLocation, -1);\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(2465).A+"",width:"399",height:"300"})}),"\n",(0,r.jsx)(n.p,{children:"Try to add more convolution kernels and change effectsToApply to see what happens."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}},2234:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/files/mr-survivor-7670d0ffeeb4a7488b1aef9416245cb9.jpg"},7307:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/image-processing-blur-1665781cc9c2dde36e2131ef82d6fe98.png"},2465:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/image-processing-effects-2-799baae8d383bb2842c0ef824eb5d536.png"},9348:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/image-processing-effects-1520ffba992f9c2c3469d7ef615d8ec4.png"},603:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/image-processing-kernel-52a1f25fee9ad155f8c24815d1903c6e.png"},3687:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/image-processing-swap-color-105fa604213755c9351ef6ecd4e24bfb.png"},5175:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/image-processing-texture-2450119d25565450a0442b0a98a505a4.png"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var r=t(6540);const a={},i=r.createContext(a);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);