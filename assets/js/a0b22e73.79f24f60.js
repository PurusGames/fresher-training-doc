"use strict";(self.webpackChunkfresher_training_doc=self.webpackChunkfresher_training_doc||[]).push([[673],{9167:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var r=t(4848),s=t(8453);const i={},o="Behavior Tree",c={id:"Topics/behavior-tree",title:"Behavior Tree",description:"Key concepts",source:"@site/docs/Topics/6.behavior-tree.md",sourceDirName:"Topics",slug:"/Topics/behavior-tree",permalink:"/fresher-training-doc/docs/Topics/behavior-tree",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Topics/6.behavior-tree.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"State Machine",permalink:"/fresher-training-doc/docs/Topics/state-machine"}},a={},d=[{value:"Key concepts",id:"key-concepts",level:3},{value:"Nodes",id:"nodes",level:3},{value:"Robot example: searching for objects",id:"robot-example-searching-for-objects",level:3},{value:"Implementations",id:"implementations",level:3}];function l(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"behavior-tree",children:"Behavior Tree"})}),"\n",(0,r.jsx)(n.h3,{id:"key-concepts",children:"Key concepts"}),"\n",(0,r.jsxs)(n.p,{children:["A behavior tree hierarchical model used in artificial intelligence (AI) to control decision-making and behaviors, particularly in robotics, game AI, and autonomous systems. It organizes tasks and actions into a tree structure, where each node represents a behavior or decision.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.p,{children:"The tree is followed from the top (root) to the bottom (leaves), each node decides which next step to take based on specific conditions or results (success, failure, or still running)."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A signal called ",(0,r.jsx)(n.strong,{children:'"tick"'})," is sent to the root of the tree and propagates through the tree until it reaches a leaf node."]}),"\n",(0,r.jsxs)(n.li,{children:["Any Node that receives a tick signal executes its callback. This callback must return either","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"SUCCESS"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"FAILURE"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"RUNNING"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RUNNING"})," means that the action needs more time to return a valid result."]}),"\n",(0,r.jsx)(n.li,{children:"If a Node has one or more children, it is its responsibility to propagate the tick; each Node type may have different rules about if, when, and how many times children are ticked."}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.strong,{children:"Leaf Nodes"}),", which don't have any children, are the actual commands. ",(0,r.jsx)(n.strong,{children:"Action"})," nodes are the most common type of ",(0,r.jsx)(n.strong,{children:"Leaf Nodes"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(6596).A+"",width:"600",height:"400"})}),"\n",(0,r.jsx)(n.h3,{id:"nodes",children:"Nodes"}),"\n",(0,r.jsxs)(n.p,{children:["The nodes are the individual elements that represent specific actions, decisions, or control flow mechanisms. Each node plays a role in defining how the AI behaves. There are several types of nodes, each node returns a state ",(0,r.jsx)(n.strong,{children:"(Success, Failure, Running)"})," and serving a different purpose:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(4668).A+"",width:"825",height:"644"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Action nodes: which are leaves of the behavior tree, perform a specific task or action, like moving, attacking, or playing an animation."}),"\n",(0,r.jsx)(n.li,{children:"Condition nodes: check a condition and return either success or failure, like checking if the player is in sight or if the health is low."}),"\n",(0,r.jsxs)(n.li,{children:["Control Nodes, which are manage the flow of the tree",(0,r.jsx)("br",{}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sequence Node: Executes its child nodes in order, stopping if one fails"}),"\n",(0,r.jsx)(n.li,{children:"Fallback Node (aka Selector Node): Executes its child nodes in order, stopping if one succeeds"}),"\n",(0,r.jsx)(n.li,{children:"Parallel Node: Executes multiple child nodes at the same time and returns success or failure based on how many succeed"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Decorator Node: modify a single child node with a custom policy, like Invert, Repeat / Retry, Timeout, Force Failure, Success Is Failure, etc"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"robot-example-searching-for-objects",children:"Robot example: searching for objects"}),"\n",(0,r.jsx)(n.p,{children:"Suppose we have a mobile robot that must search for specific objects in a home environment. Assume the robot already know all the objects' locations and can move around the house."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(7015).A+"",width:"646",height:"435"})}),"\n",(0,r.jsxs)(n.p,{children:["Let's start simple with the robot go to a location (we'll call it ",(0,r.jsx)(n.strong,{children:"A"}),"). The behavior tree is a simple sequence of the necessary actions: Go to the location and then look for the object."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(8753).A+"",width:"330",height:"199"})}),"\n",(0,r.jsx)(n.p,{children:"We\u2019ve chosen to represent navigation as an action node, as it may take some time for the robot to move (returning Running in the process). On the other hand, we represent vision as a condition node, assuming the robot can detect the object from a single image once it arrives at its destination."}),"\n",(0,r.jsxs)(n.p,{children:["One very common design principle is ",(0,r.jsx)(n.strong,{children:"explicit success condition"}),", which means you should almost always check before you act. For example, before moving to a location, you should check if you are already there."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(4522).A+"",width:"394",height:"327"})}),"\n",(0,r.jsxs)(n.p,{children:["Explicit success conditions use a Fallback node with a condition preceding an action. The guarded action will only execute if the condition is not met \u2014 in this example if the robot is not at location ",(0,r.jsx)(n.strong,{children:"A"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Our robot likely operates in an environment with multiple locations, and the idea is to look in all possible locations until we find the object we want. This can be done by introducing a root-level Fallback node and repeating the above behavior for each location in some specified order."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(3379).A+"",width:"1137",height:"455"})}),"\n",(0,r.jsx)(n.p,{children:"Finally, suppose that instead of looking for a single object, we want to consider several objects \u2014 let\u2019s say apples and oranges. This use case of composing conditions can be done with Parallel nodes as shown below."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If we accept either an apple or an orange (\u201cOR\u201d condition), then we succeed if one node returns Success"}),"\n",(0,r.jsx)(n.li,{children:"If we require both an apple and an orange (\u201cAND\u201d condition), then we succeed if both nodes return Success"}),"\n",(0,r.jsx)(n.li,{children:"If we care about the order of objects, e.g., you must find an apple before finding an orange, then this could be done with a Sequence node instead"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(8508).A+"",width:"1215",height:"515"})}),"\n",(0,r.jsx)(n.h3,{id:"implementations",children:"Implementations"}),"\n",(0,r.jsx)(n.p,{children:"There are several libraries and frameworks that implemented the behavior tree. But to understand the concept, we can implement a simple behavior tree from scratch."}),"\n",(0,r.jsx)(n.p,{children:"First, we need to define the statuses of the nodes, which are Success, Failure, Running and another Ready status to indicate that the node isn't ticked yet:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"enum Status {\r\n    Ready,\r\n    Success, \r\n    Failure, \r\n    Running,\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["And an abstract class for the nodes, which have a ",(0,r.jsx)(n.code,{children:"Status"})," property and a ",(0,r.jsx)(n.code,{children:"update"})," function to call ",(0,r.jsx)(n.code,{children:"tick"})," and assign the result status to the property. All nodes will inherit from this class and implement the ",(0,r.jsx)(n.code,{children:"tick"})," function."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"abstract class Node {\r\n    private _status = Status.Ready;\r\n    public get status() {\r\n        return this._status;\r\n    }\r\n\r\n    update() {\r\n        this._status = this.tick();\r\n    }\r\n\r\n    protected abstract tick(): Status;\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Action"})," nodes will receive a function that return a ",(0,r.jsx)(n.code,{children:"Status"})," as an action:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class Action extends Node {\r\n    private action: () => Status;\r\n\r\n    constructor(action: () => Status) {\r\n        super();\r\n        this.action = action;\r\n    }\r\n\r\n    protected override tick(): Status {\r\n        return this.action();\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Condition nodes will receive a function that returns a boolean as a condition:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class Condition extends Node {\r\n    private condition: () => boolean;\r\n\r\n    constructor(condition: () => boolean) {\r\n        super();\r\n        this.condition = condition;\r\n    }\r\n\r\n    protected override tick(): Status {\r\n        return this.condition() ? Status.Success : Status.Failure;\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Sequence"}),", ",(0,r.jsx)(n.code,{children:"Fallback"})," and ",(0,r.jsx)(n.code,{children:"Parallel"})," will have an array of children nodes, we need a ",(0,r.jsx)(n.code,{children:"Composite"})," class to handle the children:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"abstract class Composite extends Node {\r\n    protected children: Node[];\r\n\r\n    constructor(children: Node[]) {\r\n        super();\r\n        this.children = children;\r\n    }\r\n\r\n    addChild(child: Node) {\r\n        this.children.push(child);\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now we can implement the ",(0,r.jsx)(n.code,{children:"Sequence"})," and ",(0,r.jsx)(n.code,{children:"Fallback"}),", which will tick each child in order:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class Sequence extends Composite {\r\n    protected override tick(): Status {\r\n        for (const child of this.children) {\r\n            if (child.status === Status.Ready || child.status === Status.Running) {\r\n                child.update(); // update ready or running children\r\n            }\r\n\r\n            if (child.status !== Status.Success) {\r\n                return child.status; // return on first failure or running\r\n            }\r\n        }\r\n        return Status.Success; // all children succeeded\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class Fallback extends Composite {\r\n    protected override tick(): Status {\r\n        for (const child of this.children) {\r\n            if (child.status === Status.Ready || child.status === Status.Running) {\r\n                child.update(); // update ready or running children\r\n            }\r\n\r\n            if (child.status !== Status.Failure) {\r\n                return child.status; // return on first success or running\r\n            }\r\n        }\r\n        return Status.Failure; // all children failed\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Parallel"})," will tick all children at the same time and return ",(0,r.jsx)(n.code,{children:"Status"})," based on how many succeed:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class Parallel extends Composite {\r\n    private requiredSuccesses: number;\r\n\r\n    constructor(requiredSuccesses: number, children: Node[]) {\r\n        super(children);\r\n        this.requiredSuccesses = requiredSuccesses;\r\n    }\r\n\r\n    protected override tick(): Status {\r\n        let successCount = 0;\r\n        let runningCount = 0;\r\n\r\n        for (const child of this.children) {\r\n            if (child.status === Status.Failure) {\r\n                continue; // skip failures\r\n            }\r\n\r\n            if (child.status === Status.Ready || child.status === Status.Running) {\r\n                child.update(); // update ready or running children\r\n            }\r\n\r\n            if (child.status === Status.Success) {\r\n                successCount++;\r\n            } else if (child.status === Status.Running) {\r\n                runningCount++;\r\n            }\r\n        }\r\n\r\n        if (successCount >= this.requiredSuccesses) {\r\n            return Status.Success; // enough successes\r\n        }\r\n\r\n        return runningCount > 0 ? Status.Running : Status.Failure; // return running if any node is running, otherwise failure\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Decorator"})," will modify a single child node with a custom policy, we need an abstract class for the decorators:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"abstract class Decorator extends Node {\r\n    protected child: Node;\r\n    \r\n    constructor(child: Node) {\r\n        super();\r\n        this.child = child;\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For example, ",(0,r.jsx)(n.code,{children:"Invert"})," will invert the result of the child node:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class Invert extends Decorator {\r\n    protected override tick(): Status {\r\n        this.child.update();\r\n        if (this.child.status === Status.Success) {\r\n            return Status.Failure;\r\n        } else if (this.child.status === Status.Failure) {\r\n            return Status.Success;\r\n        }\r\n        return this.child.status;\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Or ",(0,r.jsx)(n.code,{children:"Repeat"})," will repeat the child node a number of times, return ",(0,r.jsx)(n.code,{children:"Sucess"})," if all repetitions succeed, or ",(0,r.jsx)(n.code,{children:"Failure"})," if any repetition fails:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class Repeat extends Decorator {\r\n    private count: number;\r\n    private repeated: number = 0;\r\n    \r\n    constructor(count: number, child: Node) {\r\n        super(child);\r\n        this.count = count;\r\n    }\r\n\r\n    protected override tick(): Status {\r\n        if (this.repeated < this.count) {\r\n            this.child.update();\r\n            if (this.child.status === Status.Failure) {\r\n                return Status.Failure;\r\n            }\r\n\r\n            this.repeated++;\r\n            return Status.Running;\r\n        }\r\n\r\n        return Status.Success; // All repetitions succeeded\r\n    }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We have all the basic nodes to implement a behavior tree. Let's see an example of a robot that moves to location ",(0,r.jsx)(n.strong,{children:"A"})," and then to location ",(0,r.jsx)(n.strong,{children:"B"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const robotPosition = {x: 0, y: 0};\r\n\r\nfunction atA() {\r\n    return robotPosition.x >= 10;\r\n}\r\n\r\nfunction atB() {\r\n    return robotPosition.y >= 10;\r\n}\r\n\r\nfunction moveToA() {\r\n    robotPosition.x++;\r\n    console.log("Moving to A", robotPosition.x);\r\n    return atA() ? Status.Success : Status.Running;\r\n}\r\n\r\nfunction moveToB() {\r\n    robotPosition.y++;\r\n    console.log("Moving to B", robotPosition.y);\r\n    return atB() ? Status.Success : Status.Running;\r\n}\r\n\r\nconst behaviorTree = new Sequence([\r\n    new Fallback([\r\n        new Condition(atA),\r\n        new Action(moveToA),\r\n    ]),\r\n    new Fallback([\r\n        new Condition(atB),\r\n        new Action(moveToB),\r\n    ]),\r\n]);\r\n\r\nwindow.requestAnimationFrame(() => behaviorTree.update());\n'})}),"\n",(0,r.jsx)(n.p,{children:"This example is oversimplified, but it shows how to implement a behavior tree from scratch. In a real-world scenario, you would have more complex conditions and actions, and you would need to handle more edge cases."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},4668:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/node-types-cad88277883e48ab077f09420f1490fb.png"},8753:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/robot-example-1-aeef695baa72de9652e5412a22594a0e.png"},4522:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/robot-example-2-be86a151ec20e5313c0b8203faa38e7e.png"},3379:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/robot-example-3-de90da96cb0f9242e2baf6e4103c822f.png"},8508:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/robot-example-4-132f5f207ffd3c60a7e2d02500ae1cc5.png"},7015:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/robot-example-e99b698ee3dc31897d995f455ac24dcc.png"},6596:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/tick-4155a892772542caf81fa16c824c91f8.svg"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);